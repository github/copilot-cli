<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; style-src 'self' 'unsafe-inline';">
  <title>Overlay</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: transparent;
      cursor: default;
      user-select: none;
      -webkit-app-region: no-drag;
    }

    /* By default, make everything click-through */
    #overlay-container {
      width: 100%;
      height: 100%;
      position: relative;
      pointer-events: none;
    }

    /* Canvas for drawing dots */
    #dot-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: auto;
    }

    /* Dots will be interactive when in selection mode */
    .dot {
      position: absolute;
      width: 8px;
      height: 8px;
      background: rgba(0, 122, 255, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      cursor: pointer;
      pointer-events: auto;
      transition: all 0.2s;
      transform: translate(-50%, -50%);
    }

    .dot:hover {
      background: rgba(0, 122, 255, 0.9);
      width: 12px;
      height: 12px;
      border: 2px solid rgba(255, 255, 255, 1);
    }

    .dot.selected {
      background: rgba(255, 45, 85, 0.9);
      border: 2px solid rgba(255, 255, 255, 1);
    }

    /* Label for dots */
    .dot-label {
      position: absolute;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 10px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      pointer-events: none;
      transform: translate(-50%, -120%);
      white-space: nowrap;
    }

    /* Mode indicator */
    #mode-indicator {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 8px 16px;
      border-radius: 6px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }

    #mode-indicator.visible {
      opacity: 1;
    }

    /* Highlight layer */
    .highlight {
      position: absolute;
      border: 2px solid rgba(0, 122, 255, 0.8);
      background: rgba(0, 122, 255, 0.1);
      pointer-events: none;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div id="overlay-container">
    <canvas id="dot-canvas"></canvas>
    <div id="dots-container"></div>
    <div id="mode-indicator">Selection Mode</div>
  </div>

  <script>
    // State
    let currentMode = 'passive';
    let gridType = 'coarse'; // 'coarse' or 'fine'
    let dots = [];
    const canvas = document.getElementById('dot-canvas');
    const ctx = canvas.getContext('2d');
    const dotsContainer = document.getElementById('dots-container');
    const modeIndicator = document.getElementById('mode-indicator');

    // Set canvas size
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    /**
     * Generate label for a dot based on grid position
     */
    function generateDotLabel(col, row, isFineGrid) {
      if (isFineGrid) {
        // Fine grid uses extended labeling with '+' for columns beyond Z
        // Columns 0-25 = A-Z, 26-51 = A+-Z+, etc.
        const letter = String.fromCharCode(65 + (col % 26));
        const suffix = col >= 26 ? '+' : '';
        return `${letter}${row}${suffix}`;
      } else {
        // Coarse grid uses simple A-Z + row number (wrapping after Z)
        return `${String.fromCharCode(65 + (col % 26))}${row}`;
      }
    }

    /**
     * Generate coarse grid of dots (100px spacing)
     */
    function generateCoarseGrid() {
      const spacing = 100;
      const dots = [];
      
      // Start at spacing pixels from edge (first dot at x=spacing, y=spacing)
      for (let x = spacing; x < window.innerWidth; x += spacing) {
        for (let y = spacing; y < window.innerHeight; y += spacing) {
          // Column index starts at 0 for first dot
          const col = Math.floor((x - spacing) / spacing);
          const row = Math.floor((y - spacing) / spacing);
          dots.push({
            id: `dot-${x}-${y}`,
            x,
            y,
            label: generateDotLabel(col, row, false)
          });
        }
      }
      
      return dots;
    }

    /**
     * Generate fine grid of dots (50px spacing)
     */
    function generateFineGrid() {
      const spacing = 50;
      const dots = [];
      
      // Start at spacing pixels from edge (first dot at x=spacing, y=spacing)
      for (let x = spacing; x < window.innerWidth; x += spacing) {
        for (let y = spacing; y < window.innerHeight; y += spacing) {
          // Column index starts at 0 for first dot
          const col = Math.floor((x - spacing) / spacing);
          const row = Math.floor((y - spacing) / spacing);
          dots.push({
            id: `dot-${x}-${y}`,
            x,
            y,
            label: generateDotLabel(col, row, true)
          });
        }
      }
      
      return dots;
    }

    /**
     * Generate dots based on current grid type
     */
    function generateDots() {
      return gridType === 'fine' ? generateFineGrid() : generateCoarseGrid();
    }

    /**
     * Render dots on the overlay
     */
    function renderDots() {
      // Clear previous dots
      dotsContainer.innerHTML = '';
      
      if (currentMode !== 'selection') {
        return; // Only show dots in selection mode
      }

      dots.forEach(dot => {
        const dotEl = document.createElement('div');
        dotEl.className = 'dot';
        dotEl.style.left = dot.x + 'px';
        dotEl.style.top = dot.y + 'px';
        dotEl.dataset.id = dot.id;
        
        // Add label
        const labelEl = document.createElement('div');
        labelEl.className = 'dot-label';
        labelEl.textContent = dot.label;
        labelEl.style.left = dot.x + 'px';
        labelEl.style.top = dot.y + 'px';
        
        // Click handler
        dotEl.addEventListener('click', () => {
          selectDot(dot);
        });

        dotsContainer.appendChild(dotEl);
        dotsContainer.appendChild(labelEl);
      });
    }

    /**
     * Handle dot selection
     */
    function selectDot(dot) {
      console.log('Dot selected:', dot);
      
      // Visual feedback
      const dotEl = dotsContainer.querySelector(`[data-id="${dot.id}"]`);
      if (dotEl) {
        dotEl.classList.add('selected');
        setTimeout(() => dotEl.classList.remove('selected'), 500);
      }

      // Send to main process
      window.electronAPI.selectDot({
        id: dot.id,
        x: dot.x,
        y: dot.y,
        label: dot.label,
        timestamp: Date.now()
      });
    }

    /**
     * Update mode display
     */
    function updateModeDisplay() {
      if (currentMode === 'selection') {
        modeIndicator.textContent = 'Selection Mode - Click a dot';
        modeIndicator.classList.add('visible');
      } else {
        modeIndicator.classList.remove('visible');
      }
      
      renderDots();
    }

    // Listen for mode changes from main process
    window.electronAPI.onModeChanged((mode) => {
      console.log('Mode changed to:', mode);
      currentMode = mode;
      updateModeDisplay();
    });

    // Initialize
    window.electronAPI.getState().then(state => {
      currentMode = state.overlayMode;
      dots = generateDots();
      updateModeDisplay();
    });

    // Handle window resize
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      dots = generateDots();
      renderDots();
    });

    // Listen for grid type changes (future enhancement)
    // Could be triggered via IPC message from chat window
  </script>
</body>
</html>
